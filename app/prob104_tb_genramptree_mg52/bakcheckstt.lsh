; Reads all of the stt files in framework tmp directories
; Also, reads sttlong.csv in problem directories, generated by grouptest.r
; then compares the two record by record to see that data matches
; This is done as a double check for R scripts when printing charts

; These are R column variables
; use these for double check of loading stt file

; part 1 read stt files from tmp framework directories
(defconstant gen 50)   ; number of generations for evolution, stt files have 51 records
(defconstant indrun 30) ; number of independent runs, ie random_seed=1..30
(defconstant hdr_row "RowNum,Kernel,ProblemNum,IndRunNum,wADF,ADF,Types,Constraints,acgpwhat,MaxTreeDepth,GenNum,SubPopNum,MeanStdFitnessOfGen,StdFitnessBestOfGenInd,StdFitnessWorstOfGenInd,MeanTreeSizeOfGen,MeanTreeDepthOfGen,TreeSizeBestOfGenInd,TreeDepthBestOfGenInd,TreeSizeWorstOfGenInd,TreeDepthWorstOfGenInd,MeanStdFitnessOfRun,StdFitnessBestOfRunInd,StdFitnessWorstOfRunInd,MeanTreeSizeOfRun,MeanTreeDepthOfRun,TreeSizeBestOfRunInd,TreeDepthBestOfRunInd,TreeSizeWorstOfRunInd,TreeDepthWorstOfRunInd")

; part 1 vars
(defvar gcnt)        ; define variable for gcnt
(setq gcnt 0)        ; generation count for ind run, needed to fill out stt record upon reconstruction
(defvar lcnt)        ; define variable for lcnt
(setq lcnt 0)        ; total number of lines read from stt files
(defvar dcnt)        ; define variable directory count
(setq dcnt 0)        ; directory count, should equal a filter for file names containing adf string
(defvar fcnt)        ; define variable file count stt
(setq fcnt 0)        ; set value file count stt
(defvar pth)         ; path to stt file
(defvar flistroot)   ; file list from root of problem
(defvar flist)       ; tmp dir file list
(defvar pthstt)      ; path plus file name for stt file
(defvar sttlns)      ; contents of stt file
(defvar fnpstt)      ; file name prefix stt file 
(defvar fnpitems)    ; file name prefix items
(defvar sttrowitems) ; a row of information in an stt file
(defvar sttlongrow_all) ; row of all stt long data
(defvar sttlongrow_nr)  ; row of stt long data, no row numbers
(defvar fd)          ; file descriptor for output file
(setq fd (open-write "sttlong1.csv"))

; part 2 vars
(defvar dlcnt)          ; define variable for dlcnt
(setq dlcnt 0)          ; total number of lines read from data sttlong.csv
(defvar dpthstt)        ; path plus file name for data subdirectory sttlong.csv file
(defvar dsttlns)        ; contents of data sttlong.csv file
(defvar dsttrowitems)   ; a row of information in a data sttlong.csv file
(defvar dnewsttrowitems)  ; a new row of information in a data sttlong.csv file
(defvar dsttlongrow_all); row of all information data sttlong.csv file 
(defvar dsttlongrow_nr) ; row of all information data sttlong.csv file , no row numbers
(defvar rkval)          ; the value associated with key hashtable searches
(defvar drownumtxt)     ; row number text, used to delete space padding left side of RowNum in data sttlong.csv
 
;hash table key is RowNum, value is rest of stt record 
; idea is that mksttlong.bash sttlong.csv and this sttlong1.csv will be a 1 to 1 match for data based on RowNum
;1 is an estimate of size of hash table, just a place holder here
; hash table will grow to a much larger number since we have so many unique keys
(defvar htstt)       ; define a variable for hash table for stt
(setq htstt (htable 1 =-equality)) 

(print "Phase 1: building sttlong1.csv, like mksttlong.bash does, useful for double checking")
(setq flistroot (files "."))
(do ((it1 flistroot)) while (<> flistroot -1) 
 (when (dirp it1)
  (when (str-find "adf" it1 0)
   (setq pth (str-cat (str-cat (str-cat (pwd) "/") it1) "/tmp"))
   ;(print pth)
   (setq flist (files pth))
   (do ((it2 flist)) while (<> it2 -1)
    (when (str-find "stt" it2 0)
     (setq pthstt (str-cat (str-cat (str-cat (str-cat (str-cat (pwd) "/") it1) "/tmp") "/") it2))
     ;(print pthstt)
     ;(print it2)
     (setq fnpstt (basename it2 "stt"))
     ;(print fnpstt)
     (setq fnpitems(str-split fnpstt "-"))
     ;(print fnpitems)
     (incr fcnt) 
     (setq sttlns (lines pthstt))
     (setq gcnt 0)
     (do ((it3 sttlns)) while (<> it3 -1)
      ;(print it3)
      (setq sttrowitems(str-split it3 " "))

      ; file name has encodings (list form)
      ;(prin fnpitems)
      ; inside the stt file are rows of nformation (list form)
      ;(print sttrowitems)

      ; now convert items back to comma separated row
      ;(prin (str-join "," fnpitems))
      ;(print (str-join "," sttrowitems))

      ; get length of items do delete last comma
      ;(printf "%d\n" (+ (length fnpitems) (length sttrowitems)))
      (setq sttlongrow_all (sprintf "%d,%s,%s" (+ lcnt 1) (str-join "," fnpitems) (str-join "," sttrowitems)))
      (setq sttlongrow_nr (sprintf "%s,%s" (str-join "," fnpitems) (str-join "," sttrowitems)))

      ; delete last comma
      (setq sttlongrow_all (str-del sttlongrow_all (- (length sttlongrow_all) 1) 1))
      (setq sttlongrow_nr (str-del sttlongrow_nr (- (length sttlongrow_nr) 1) 1))
      (htstt (+ lcnt 1) sttlongrow_nr) ; key == RowNum, val == rest of stt record 

      ; print actual stt long row with commas
      ;(print sttlongrow_all)

      ; this is writing out sttlong1.csv just like mksttlong.bash does, useful for double checking
      (when (= lcnt 0) 
       (writing fd (printf "%s\n" hdr_row))
      )
      (writing fd (printf "%s\n" sttlongrow_all))

      ; increment global line count of stt rows processed
      (incr lcnt) 

      ; increment generation line count of stt rows processed
      (incr gcnt)

      ; print progress symbol
      (when (= (modi lcnt 500) 0)
       (printf "%s" "=")
       (flush)
      )
     )
     ; need to fill out rows if a particular gp run finished early
     (while (<> (+ gen 1) gcnt)
      ; get length of items do delete last comma
      ;(printf "%d\n" (+ (length fnpitems) (length sttrowitems)))
      (setq sttlongrow_all (sprintf "%d,%s,%s" (+ lcnt 1) (str-join "," fnpitems) (str-join "," sttrowitems)))
      (setq sttlongrow_nr (sprintf "%s,%s" (str-join "," fnpitems) (str-join "," sttrowitems)))

      ; delete last comma
      (setq sttlongrow_all (str-del sttlongrow_all (- (length sttlongrow_all) 1) 1))
      (setq sttlongrow_nr (str-del sttlongrow_nr (- (length sttlongrow_nr) 1) 1))
      (htstt (+ lcnt 1) sttlongrow_nr) ; key == RowNum, val == rest of stt record 

      ;(writing fd (printf "%s\n" sttlongrow_all))
      ;(printf "gen == %d, gcnt=%d\n" (+ gen 1) gcnt )
      ;(printf "%s\n" sttlongrow_all)
      ;(flush)

      (incr lcnt) 
      (incr gcnt)
     )
    )
   )
   ; increment global line count of framworks processed
   (incr dcnt) 
  )
 )
)
(print)
(exit)
(print "Phase 2: checking sttlong1.csv, against mksttlong.bash data/sttlong.csv")
;(printf "DirCntTotal=%l\n" dcnt)
;(printf "STTCntTotal=%l\n" fcnt)
;(printf "Double Check: STTTotal= %l / IndRun=%l = %l\n" fcnt indrun (/ fcnt indrun))
;(printf "Total STT Lines Read = %l\n" lcnt)

;(print (htable-keys htstt))
;(print (htable-info htstt))
;(print (htable-size htstt))

;part 2, let's compare sttlong1.csv genrated from this file to 
; sttlong.csv generated from mksttlong.bash using htstt,
; they should be the same

(setq flistroot (files "."))
(do ((it1 flistroot)) while (<> flistroot -1) 
 (when (dirp it1)
  (when (str-find "data" it1 0)
   (setq dpthstt(str-cat (str-cat (str-cat (pwd) "/") it1) "/sttlong.csv"))
   (print dpthstt)
   (when (filep dpthstt)
    ;(print "data sttlong.csv exists.")
    (setq dsttlns (lines dpthstt))
    (do ((it2 dsttlns)) while (<> it2 -1)
     ;(print it2)
     (setq dsttrowitems (str-split (str-stripl it2) ","))

     ; get the row num for this record
     (setq drownumtxt (str-stripl(nth 0 dsttrowitems)))
     ;(print (str-val drownumtxt) )
     (setq rkval (htstt (str-val drownumtxt)))

     ; get row of data minus the row number, used for comparison    
     (setq dsttrowitems (str-split (str-stripl it2) ","))
     (setq dsttlongrow_nr (str-join "," (cdr dsttrowitems)))
     ;(print rkval)
     ;(print dsttlongrow_nr) 
     ; print out when sttlong1.csv and sttlong.csv are not equal
     (when (<> rkval dsttlongrow_nr) 
      ;(prin rkval) 
      ;(print dsttlongrow_nr)
      (when (not (emptyp rkval))
       (prin (str-val drownumtxt) )
       (print "FAIL") 
      )
     )

     ; print progress symbol
     (when (= (modi dlcnt 500) 0)
      (printf "%s" "+")
      (flush)
     )

     ; inside data sttlong.csv  are rows of nformation (list form)
     ;(print dsttrowitems)

     (incr dlcnt) 
    )
   )
  )
 )
)
(print)

; some statistics about sttlong1.csv and sttlong.csv 
(printf "DirCntTotal=%l\n" dcnt)
(printf "STTCntTotal=%l\n" fcnt)
(printf "Double Check: (STTTotal= %l / IndRun=%l) = %l\n" fcnt indrun (/ fcnt indrun))
(printf "Total STT Lines Read = %l\n" lcnt)
(printf "Total data sttlong.csv Lines Read = %l\n" dlcnt)
